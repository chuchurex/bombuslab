<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Configura tu Velador 3D | Personaliza Dimensiones y Tech | Bombus</title>

    <!-- SEO Meta Tags -->
    <meta name="description" content="Diseña tu velador perfecto en 3D. Personaliza dimensiones, materiales y agrega tecnología: USB, carga inalámbrica, LED. Cotiza directo por WhatsApp.">
    <meta name="keywords" content="configurador veladores, diseñar velador, velador personalizado, velador 3D, velador USB, carga inalámbrica">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://bombuslab.cl/bombus_configurador.html">

    <!-- Open Graph -->
    <meta property="og:type" content="product">
    <meta property="og:url" content="https://bombuslab.cl/bombus_configurador.html">
    <meta property="og:title" content="Configura tu Velador 3D | Bombus">
    <meta property="og:description" content="Diseña tu velador perfecto. Personaliza dimensiones, materiales y tecnología integrada.">
    <meta property="og:image" content="https://bombuslab.cl/assets/images/bombus_og_image.png">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Configura tu Velador 3D | Bombus">
    <meta name="twitter:description" content="Diseña tu velador perfecto con nuestro configurador 3D interactivo.">

    <link rel="icon" type="image/png" href="assets/images/bombus_favicon.png">
    <meta name="theme-color" content="#1A1A1A">

    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;600;700&family=DM+Sans:wght@400;500;600&display=swap" rel="stylesheet">
    <script src="assets/js/analytics.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --color-bg: #1A1A1A;
            --color-text: #FFFFFF;
            --color-text-muted: rgba(255, 255, 255, 0.6);
            --color-accent: #F5A623;
            --honey: #F5A623;
            --honey-dark: #C4841D;
            --charcoal: #1A1A1A;
            --border: rgba(255, 255, 255, 0.1);
            --success: #2E7D32;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'DM Sans', sans-serif;
            background: var(--color-bg);
            color: var(--color-text);
            overflow: hidden;
            /* Prevent scrolling on body */
        }

        /* Header */
        header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem 2rem;
            background: rgba(26, 26, 26, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            height: 80px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            text-decoration: none;
            color: var(--color-text);
        }

        .logo img {
            height: 52px;
            width: auto;
        }

        .logo span {
            font-family: 'Playfair Display', serif;
            font-size: 1.25rem;
            letter-spacing: 0.05em;
            font-weight: 700;
        }

        .back-link {
            color: var(--color-text-muted);
            text-decoration: none;
            font-size: 0.9rem;
            transition: color 0.3s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .back-link:hover {
            color: var(--color-accent);
        }

        /* Layout */
        .main {
            display: grid;
            grid-template-columns: 1fr 400px;
            height: 100vh;
            padding-top: 80px;
            /* Header height */
        }

        @media (max-width: 900px) {
            .main {
                grid-template-columns: 1fr;
                height: auto;
                min-height: 100vh;
            }

            .viewer {
                height: 45vh;
                min-height: 300px;
            }

            .panel {
                height: auto;
                max-height: none;
                padding: 1.5rem;
            }

            .model-name {
                top: 1rem;
                left: 1rem;
            }

            .model-name h1 {
                font-size: 1.5rem;
            }

            .model-name p {
                font-size: 0.85rem;
                max-width: 250px;
            }

            .viewer-hint {
                font-size: 0.7rem;
                padding: 0.4rem 0.8rem;
                bottom: 1rem;
            }

            .section-title {
                font-size: 1rem;
            }

            .colors {
                gap: 0.75rem;
            }

            .color-opt {
                width: 35px;
                height: 35px;
            }

            .gadget {
                padding: 0.8rem;
            }

            .gadget-name {
                font-size: 0.9rem;
            }

            .gadget-desc {
                font-size: 0.75rem;
            }

            .summary-row.total .value {
                font-size: 1.5rem;
            }

            .cta-btn {
                padding: 1rem;
                font-size: 0.9rem;
            }

            header {
                padding: 1rem 1.5rem;
                height: 70px;
            }

            .logo img {
                height: 44px;
            }

            .logo span {
                font-size: 1rem;
            }

            .back-link {
                font-size: 0.8rem;
            }

            .back-link svg {
                width: 16px;
                height: 16px;
            }
        }

        @media (max-width: 480px) {
            .viewer {
                height: 40vh;
                min-height: 280px;
            }

            .panel {
                padding: 1rem;
            }

            .section {
                margin-bottom: 1.5rem;
                padding-bottom: 1.5rem;
            }

            .model-name h1 {
                font-size: 1.25rem;
            }

            .dim-control {
                margin-bottom: 1rem;
            }

            .back-link span {
                display: none;
            }
        }

        /* Viewer */
        .viewer {
            background: #151515;
            position: relative;
            overflow: hidden;
        }

        #canvas {
            width: 100%;
            height: 100%;
            display: block;
            outline: none;
        }

        .model-name {
            position: absolute;
            top: 2rem;
            left: 2rem;
            color: white;
            pointer-events: none;
        }

        .model-name h1 {
            font-family: 'Playfair Display', serif;
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            color: var(--color-text);
        }

        .model-name p {
            color: var(--color-text-muted);
            font-size: 1rem;
            max-width: 400px;
        }

        .viewer-hint {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.8);
            padding: 0.5rem 1rem;
            border-radius: 50px;
            font-size: 0.8rem;
            backdrop-filter: blur(4px);
            pointer-events: none;
        }

        /* Decorative Bumblebee */
        .viewer-bee {
            position: absolute;
            top: 28%;
            left: 58%;
            width: 90px;
            height: auto;
            opacity: 0.85;
            transform: scaleX(-1);
            pointer-events: none;
            z-index: 10;
            animation: floatBee 4s ease-in-out infinite;
        }

        @keyframes floatBee {
            0%, 100% {
                transform: scaleX(-1) translateY(0);
            }
            50% {
                transform: scaleX(-1) translateY(-8px);
            }
        }

        @media (max-width: 900px) {
            .viewer-bee {
                width: 50px;
                right: 10%;
            }
        }

        /* Panel */
        .panel {
            background: #202020;
            padding: 2rem;
            overflow-y: auto;
            border-left: 1px solid var(--border);
        }

        .section {
            margin-bottom: 2rem;
            padding-bottom: 2rem;
            border-bottom: 1px solid var(--border);
        }

        .section:last-of-type {
            border-bottom: none;
        }

        .section-title {
            font-weight: 600;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1.1rem;
            color: var(--color-text);
        }

        /* Dimensions */
        .dim-control {
            margin-bottom: 1.5rem;
        }

        .dim-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            margin-bottom: 0.8rem;
            color: var(--color-text-muted);
        }

        .dim-value {
            font-weight: 600;
            color: var(--color-accent);
        }

        .dim-slider {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }

        .dim-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--color-accent);
            cursor: pointer;
            border: 2px solid #202020;
            box-shadow: 0 0 10px rgba(245, 166, 35, 0.3);
            transition: transform 0.2s;
        }

        .dim-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        /* Colors (Hidden visually but kept for logic if needed, or styled minimally) */
        /* Since we moved to wireframe, color selection might feel weird if it doesn't change anything visually. 
           Let's update the wireframe color or opacity slightly based on this, or just keep it for the order.
           We'll keep the buttons but style them dark. */
        .colors {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .color-opt {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid rgba(255, 255, 255, 0.1);
            transition: all 0.2s;
            position: relative;
        }

        .color-opt:hover {
            transform: scale(1.1);
            border-color: var(--color-text-muted);
        }

        .color-opt.active {
            border-color: var(--color-accent);
            transform: scale(1.1);
        }

        .color-opt::after {
            content: '';
            position: absolute;
            inset: -4px;
            border-radius: 50%;
            border: 1px solid transparent;
        }

        .color-opt.active::after {
            border-color: var(--color-accent);
        }

        /* Gadgets */
        .gadget {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            margin-bottom: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }

        .gadget:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .gadget.active {
            background: rgba(245, 166, 35, 0.1);
            border-color: rgba(245, 166, 35, 0.3);
        }

        .gadget-check {
            width: 20px;
            height: 20px;
            border: 1.5px solid var(--color-text-muted);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            transition: all 0.2s;
            color: transparent;
        }

        .gadget.active .gadget-check {
            background: var(--color-accent);
            border-color: var(--color-accent);
            color: #1A1A1A;
        }

        .gadget-info {
            flex: 1;
        }

        .gadget-name {
            font-weight: 500;
            font-size: 0.95rem;
            color: var(--color-text);
        }

        .gadget-desc {
            font-size: 0.8rem;
            color: var(--color-text-muted);
            margin-top: 0.2rem;
        }

        .gadget-price {
            font-weight: 600;
            color: var(--color-accent);
            font-size: 0.9rem;
        }

        /* Summary */
        .summary {
            background: rgba(0, 0, 0, 0.3);
            color: white;
            padding: 1.5rem;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .summary-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            color: var(--color-text-muted);
        }

        .summary-row.total {
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 1rem;
            margin-top: 1rem;
            margin-bottom: 0;
            color: var(--color-text);
        }

        .summary-row.total .label {
            font-weight: 600;
            font-size: 1.1rem;
        }

        .summary-row.total .value {
            font-family: 'Playfair Display', serif;
            font-size: 1.8rem;
            color: var(--color-accent);
        }

        /* CTA */
        .cta-btn {
            width: 100%;
            padding: 1.2rem;
            margin-top: 1.5rem;
            background: var(--color-accent);
            color: #1A1A1A;
            border: none;
            border-radius: 50px;
            font-family: inherit;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .cta-btn:hover {
            background: #FFB74D;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(245, 166, 35, 0.3);
        }
    </style>
</head>

<body>

    <header>
        <a href="index.html" class="logo">
            <img src="assets/images/bombus_final_inverted_honey.png" alt="Bombus Isotype">
            <span>BOMBUS</span>
        </a>
        <a href="bombus_galeria.html" class="back-link">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M19 12H5" />
                <path d="M12 19l-7-7 7-7" />
            </svg>
            Volver a galería
        </a>
    </header>

    <main class="main">
        <div class="viewer">
            <canvas id="canvas"></canvas>
            <div class="model-name">
                <h1 id="nombre">Modelo</h1>
                <p id="desc">Descripción</p>
            </div>
            <div class="viewer-hint">Arrastra para rotar • Scroll para zoom</div>
            <img src="assets/images/bombus_bee_honey.png" class="viewer-bee" alt="">
        </div>

        <div class="panel">
            <!-- Dimensiones -->
            <div class="section">
                <div class="section-title">Dimensiones</div>
                <div class="dim-control">
                    <div class="dim-label"><span>Ancho</span><span class="dim-value" id="v-ancho">45 cm</span></div>
                    <input type="range" class="dim-slider" id="s-ancho" min="35" max="60" value="45">
                </div>
                <div class="dim-control">
                    <div class="dim-label"><span>Profundidad</span><span class="dim-value" id="v-prof">40 cm</span></div>
                    <input type="range" class="dim-slider" id="s-prof" min="30" max="50" value="40">
                </div>
                <div class="dim-control">
                    <div class="dim-label"><span>Alto</span><span class="dim-value" id="v-alto">55 cm</span></div>
                    <input type="range" class="dim-slider" id="s-alto" min="40" max="70" value="55">
                </div>
            </div>

            <!-- Color -->
            <div class="section">
                <div class="section-title">Color Referencial (Cuerpo)</div>
                <div class="colors">
                    <div class="color-opt active" style="background:#FAFAFA;" data-color="0xFFFFFF" data-name="Blanco" data-mod="-10000"></div>
                    <div class="color-opt" style="background:#1A1A1A;" data-color="0x444444" data-name="Negro" data-mod="-5000"></div>
                    <div class="color-opt" style="background:#D4A574;" data-color="0xD4A574" data-name="Roble" data-mod="15000"></div>
                    <div class="color-opt" style="background:#5D4037;" data-color="0x8D6E63" data-name="Nogal" data-mod="25000"></div>
                    <div class="color-opt" style="background:#DEB887;" data-color="0xE0C097" data-name="Pino" data-mod="0"></div>
                </div>
                <p style="font-size:0.8rem; color:var(--color-text-muted); margin-top:0.5rem; font-style:italic;">Nota: El visor muestra un esquema técnico. El color seleccionado se aplicará a su pedido.</p>
            </div>

            <!-- Gadgets -->
            <div class="section">
                <div class="section-title">Extras Tech</div>
                <div class="gadget" data-gadget="usb" data-precio="12000">
                    <div class="gadget-check">✓</div>
                    <div class="gadget-info">
                        <div class="gadget-name">USB-A + USB-C</div>
                        <div class="gadget-desc">2 puertos de carga rápida integrados</div>
                    </div>
                    <div class="gadget-price">+$12.000</div>
                </div>
                <div class="gadget" data-gadget="wireless" data-precio="25000">
                    <div class="gadget-check">✓</div>
                    <div class="gadget-info">
                        <div class="gadget-name">Carga inalámbrica</div>
                        <div class="gadget-desc">Qi / MagSafe invisible bajo cubierta</div>
                    </div>
                    <div class="gadget-price">+$25.000</div>
                </div>
                <div class="gadget" data-gadget="led" data-precio="18000">
                    <div class="gadget-check">✓</div>
                    <div class="gadget-info">
                        <div class="gadget-name">Luz LED ambiente</div>
                        <div class="gadget-desc">Sensor táctil, luz cálida inferior</div>
                    </div>
                    <div class="gadget-price">+$18.000</div>
                </div>
            </div>

            <!-- Summary -->
            <div class="summary">
                <div class="summary-row">
                    <span>Modelo base</span>
                    <span id="sum-base">$89.000</span>
                </div>
                <div class="summary-row">
                    <span>Material</span>
                    <span id="sum-mat">+$0</span>
                </div>
                <div class="summary-row">
                    <span>Extras</span>
                    <span id="sum-extras">$0</span>
                </div>
                <div class="summary-row total">
                    <span class="label">Total</span>
                    <span class="value" id="sum-total">$89.000</span>
                </div>
            </div>

            <button class="cta-btn" onclick="cotizar()">
                Cotizar por WhatsApp
            </button>
        </div>
    </main>

    <script>
        // Complete catalog with all 44 models
        // ... (Keep existing models data usually, but ensuring it's not cut off if using replace)
        // Actually, I can keep the JS logic mostly as is, but modify the init and material logic.
        // I will redefine the whole script block to be safe and ensure the material logic is updated to Wireframe.

        const modelos = {
            // SIMPLE
            S01: { nombre: 'Cubo', desc: 'Forma cúbica pura con 1 cajón', precio: 75000, cajones: 1, categoria: 'simple', forma: 'cubo' },
            S02: { nombre: 'Aire', desc: 'Flotante minimalista con cajón oculto', precio: 85000, cajones: 1, categoria: 'simple', forma: 'flotante' },
            S03: { nombre: 'Torre', desc: 'Vertical con 3 cajones estrechos', precio: 95000, cajones: 3, categoria: 'simple', forma: 'torre' },
            S04: { nombre: 'Plano', desc: 'Bajo y ancho, 2 cajones lado a lado', precio: 99000, cajones: 2, categoria: 'simple', forma: 'horizontal' },
            S05: { nombre: 'Nicho', desc: 'Repisa abierta + 1 cajón inferior', precio: 79000, cajones: 1, categoria: 'simple', forma: 'nicho' },
            S06: { nombre: 'Duo', desc: '2 cajones apilados, sin patas', precio: 85000, cajones: 2, categoria: 'simple', forma: 'standard' },
            S07: { nombre: 'Zócalo', desc: 'Base corrida, 2 cajones', precio: 89000, cajones: 2, categoria: 'simple', forma: 'zocalo' },
            S08: { nombre: 'Riel', desc: 'Flotante con riel metálico', precio: 92000, cajones: 1, categoria: 'simple', forma: 'flotante' },
            S09: { nombre: 'Cero', desc: 'Sin tiradores, apertura push', precio: 95000, cajones: 2, categoria: 'simple', forma: 'standard' },
            S10: { nombre: 'Mesa', desc: 'Forma de mesa con repisa', precio: 65000, cajones: 0, categoria: 'simple', forma: 'mesa' },
            S11: { nombre: 'Doble Aire', desc: '2 módulos flotantes apilados', precio: 110000, cajones: 2, categoria: 'simple', forma: 'flotante' },
            S12: { nombre: 'Escalón', desc: 'Asimétrico, 2 niveles', precio: 88000, cajones: 1, categoria: 'simple', forma: 'escalon' },

            // CÁLIDO
            C01: { nombre: 'Ratán', desc: 'Frentes de ratán tejido', precio: 99000, cajones: 2, categoria: 'calido', forma: 'standard' },
            C02: { nombre: 'Nudo', desc: 'Madera con veta expuesta', precio: 120000, cajones: 1, categoria: 'calido', forma: 'standard' },
            C03: { nombre: 'Cabaña', desc: 'Rústico con puerta', precio: 95000, cajones: 0, categoria: 'calido', forma: 'puerta' },
            C04: { nombre: 'Trenza', desc: 'Detalle trenzado', precio: 89000, cajones: 1, categoria: 'calido', forma: 'standard' },
            C05: { nombre: 'Orgánico', desc: 'Bordes redondeados', precio: 115000, cajones: 2, categoria: 'calido', forma: 'organico' },
            C06: { nombre: 'Tronco', desc: 'Aspecto natural', precio: 135000, cajones: 1, categoria: 'calido', forma: 'cilindro' },
            C07: { nombre: 'Canasto', desc: 'Con canasto de fibra', precio: 85000, cajones: 1, categoria: 'calido', forma: 'nicho' },
            C08: { nombre: 'Bambú', desc: 'Estructura de bambú', precio: 92000, cajones: 2, categoria: 'calido', forma: 'standard' },
            C09: { nombre: 'Terracota', desc: 'Madera + detalle cerámico', precio: 105000, cajones: 1, categoria: 'calido', forma: 'standard' },
            C10: { nombre: 'Cuerda', desc: 'Tiradores de cuerda', precio: 88000, cajones: 2, categoria: 'calido', forma: 'standard' },

            // MODERNO
            M01: { nombre: 'Neo', desc: 'Líneas angulares, metal', precio: 110000, cajones: 2, categoria: 'moderno', forma: 'angular' },
            M02: { nombre: 'Smart', desc: 'Diseñado para tech', precio: 140000, cajones: 2, categoria: 'moderno', forma: 'standard' },
            M03: { nombre: 'Cristal', desc: 'Tapa de vidrio', precio: 125000, cajones: 1, categoria: 'moderno', forma: 'cristal' },
            M04: { nombre: 'Acero', desc: 'Estructura metálica', precio: 115000, cajones: 2, categoria: 'moderno', forma: 'marco' },
            M05: { nombre: 'LED', desc: 'Luz LED integrada', precio: 135000, cajones: 2, categoria: 'moderno', forma: 'standard' },
            M06: { nombre: 'Seguro', desc: 'Cerradura biométrica', precio: 165000, cajones: 2, categoria: 'moderno', forma: 'standard' },
            M07: { nombre: 'Cantilever', desc: 'Flotante en C', precio: 105000, cajones: 1, categoria: 'moderno', forma: 'cantilever' },
            M08: { nombre: 'Hexágono', desc: 'Forma hexagonal', precio: 98000, cajones: 1, categoria: 'moderno', forma: 'hexagono' },
            M09: { nombre: 'Espejo', desc: 'Frentes espejados', precio: 130000, cajones: 2, categoria: 'moderno', forma: 'standard' },
            M10: { nombre: 'Curva', desc: 'Bordes curvos', precio: 118000, cajones: 2, categoria: 'moderno', forma: 'organico' },
            M11: { nombre: 'Cilindro', desc: 'Forma cilíndrica', precio: 108000, cajones: 1, categoria: 'moderno', forma: 'cilindro' },
            M12: { nombre: 'Marco', desc: 'Estructura tipo marco', precio: 112000, cajones: 1, categoria: 'moderno', forma: 'marco' },
            M13: { nombre: 'Panel', desc: 'Panel estriado', precio: 105000, cajones: 2, categoria: 'moderno', forma: 'standard' },
            M14: { nombre: 'Mármol', desc: 'Tapa efecto mármol', precio: 145000, cajones: 2, categoria: 'moderno', forma: 'cristal' },

            // CLÁSICO
            K01: { nombre: 'Colonial', desc: 'Molduras clásicas', precio: 125000, cajones: 2, categoria: 'clasico', forma: 'colonial' },
            K02: { nombre: 'Retro', desc: 'Patas cónicas, años 60', precio: 115000, cajones: 2, categoria: 'clasico', forma: 'retro' },
            K03: { nombre: 'Provenzal', desc: 'Patas torneadas', precio: 130000, cajones: 2, categoria: 'clasico', forma: 'provenzal' },
            K04: { nombre: 'Inglés', desc: 'Estilo biblioteca', precio: 135000, cajones: 1, categoria: 'clasico', forma: 'ingles' },
            K05: { nombre: 'Art Deco', desc: 'Geométrico dorado', precio: 140000, cajones: 2, categoria: 'clasico', forma: 'artdeco' },
            K06: { nombre: 'Shaker', desc: 'Simplicidad tradicional', precio: 105000, cajones: 2, categoria: 'clasico', forma: 'standard' },
            K07: { nombre: 'Viena', desc: 'Curvas estilo Thonet', precio: 118000, cajones: 1, categoria: 'clasico', forma: 'organico' },
            K08: { nombre: 'Chippendale', desc: 'Patas cabriole', precio: 155000, cajones: 2, categoria: 'clasico', forma: 'chippendale' }
        };

        // Config
        let config = {
            modelo: 'S06',
            nombre: 'Duo',
            desc: '2 cajones apilados, sin patas',
            precioBase: 85000,
            ancho: 45,
            prof: 40,
            alto: 55,
            color: 0xFFFFFF,
            colorName: 'Blanco',
            materialMod: -10000,
            gadgets: [],
            categoria: 'simple',
            forma: 'standard'
        };

        // Load from URL
        const params = new URLSearchParams(window.location.search);
        const modeloId = params.get('modelo') || 'S06';
        if (modelos[modeloId]) {
            const m = modelos[modeloId];
            config.modelo = modeloId;
            config.nombre = m.nombre;
            config.desc = m.desc;
            config.precioBase = m.precio;
            config.categoria = m.categoria;
            config.forma = m.forma;
        }

        document.getElementById('nombre').textContent = config.nombre;
        document.getElementById('desc').textContent = config.desc;

        // Three.js
        const canvas = document.getElementById('canvas');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x151515); /* Dark background matching container */

        const camera = new THREE.PerspectiveCamera(40, canvas.clientWidth / canvas.clientHeight, 0.1, 100);
        camera.position.set(1.8, 1.5, 1.8);
        camera.lookAt(0, 0.35, 0);

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // GRID
        const grid = new THREE.GridHelper(2, 20, 0x333333, 0x222222);
        scene.add(grid);

        // Group
        let nightstand = new THREE.Group();
        scene.add(nightstand);

        function buildModel() {
            while (nightstand.children.length) nightstand.remove(nightstand.children[0]);

            const w = config.ancho / 100;
            const d = config.prof / 100;
            const h = config.alto / 100;
            const cajones = modelos[config.modelo]?.cajones || 2;
            const forma = config.forma;

            // WIREFRAME MATERIALS
            const mat = new THREE.MeshBasicMaterial({
                color: 0xF5A623, // Bombus Orange
                wireframe: true,
                transparent: true,
                opacity: 0.8
            });

            // Darker material for drawers/details to add slight visual hierarchy even in wireframe
            const darkMat = new THREE.MeshBasicMaterial({
                color: 0xC4841D, // Darker orange
                wireframe: true,
                transparent: true,
                opacity: 0.5
            });

            const metalMat = darkMat;
            const glassMat = new THREE.MeshBasicMaterial({
                color: 0x90CAF9,
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });

            // Build based on forma type
            switch (forma) {
                case 'flotante': buildFlotante(w, d, h, mat, darkMat); break;
                case 'torre': buildTorre(w, d, h, mat, darkMat); break;
                case 'horizontal': buildHorizontal(w, d, h, mat, darkMat); break;
                case 'nicho': buildNicho(w, d, h, mat, darkMat); break;
                case 'mesa': buildMesa(w, d, h, mat, darkMat); break;
                case 'escalon': buildEscalon(w, d, h, mat, darkMat); break;
                case 'zocalo': buildZocalo(w, d, h, mat, darkMat); break;
                case 'cilindro': buildCilindro(w, d, h, mat, darkMat); break;
                case 'hexagono': buildHexagono(w, d, h, mat, darkMat); break;
                case 'angular': buildAngular(w, d, h, mat, darkMat, metalMat); break;
                case 'marco': buildMarco(w, d, h, mat, darkMat, metalMat); break;
                case 'cantilever': buildCantilever(w, d, h, mat, darkMat, metalMat); break;
                case 'cristal': buildCristal(w, d, h, mat, darkMat, glassMat); break;
                case 'organico': buildOrganico(w, d, h, mat, darkMat); break;
                case 'colonial': buildColonial(w, d, h, mat, darkMat); break;
                case 'retro': buildRetro(w, d, h, mat, darkMat); break;
                case 'provenzal': buildProvenzal(w, d, h, mat, darkMat); break;
                case 'chippendale': buildChippendale(w, d, h, mat, darkMat); break;
                case 'artdeco': buildArtDeco(w, d, h, mat, darkMat, metalMat); break;
                case 'ingles': buildIngles(w, d, h, mat, darkMat); break;
                case 'puerta': buildPuerta(w, d, h, mat, darkMat); break;
                case 'cubo': buildCubo(w, d, h, mat, darkMat); break;
                default: buildStandard(w, d, h, mat, darkMat, cajones);
            }

            // Add tech indicators
            addTechIndicators(w, d, h, mat);
        }



        function buildStandard(w, d, h, mat, darkMat, cajones) {
            const body = new THREE.Mesh(new THREE.BoxGeometry(w, h * 0.85, d), mat);
            body.position.y = h * 0.5;
            nightstand.add(body);

            const top = new THREE.Mesh(new THREE.BoxGeometry(w + 0.01, 0.015, d + 0.01), mat);
            top.position.y = h * 0.93;
            nightstand.add(top);

            const legH = h * 0.1;
            const legGeo = new THREE.BoxGeometry(0.025, legH, 0.025);
            [[-1, -1], [1, -1], [-1, 1], [1, 1]].forEach(([sx, sz]) => {
                const leg = new THREE.Mesh(legGeo, mat);
                leg.position.set(sx * (w / 2 - 0.02), legH / 2, sz * (d / 2 - 0.02));
                nightstand.add(leg);
            });

            const drawerH = (h * 0.72) / Math.max(cajones, 1);
            for (let i = 0; i < cajones; i++) {
                const drawer = new THREE.Mesh(new THREE.BoxGeometry(w * 0.92, drawerH * 0.85, 0.008), darkMat);
                drawer.position.set(0, h * 0.15 + (i + 0.5) * drawerH, d / 2 + 0.005);
                nightstand.add(drawer);
                const handle = new THREE.Mesh(new THREE.BoxGeometry(w * 0.2, 0.008, 0.012), darkMat);
                handle.position.set(0, h * 0.15 + (i + 0.5) * drawerH, d / 2 + 0.015);
                nightstand.add(handle);
            }
        }

        function buildFlotante(w, d, h, mat, darkMat) {
            const bodyH = h * 0.4;
            const body = new THREE.Mesh(new THREE.BoxGeometry(w, bodyH, d), mat);
            body.position.y = h * 0.7;
            nightstand.add(body);

            const drawer = new THREE.Mesh(new THREE.BoxGeometry(w * 0.92, bodyH * 0.7, 0.008), darkMat);
            drawer.position.set(0, h * 0.7, d / 2 + 0.005);
            nightstand.add(drawer);

            // Wall mount indicator
            const wallMount = new THREE.Mesh(new THREE.BoxGeometry(0.02, h * 0.5, 0.02), darkMat);
            wallMount.position.set(0, h * 0.5, -d / 2 - 0.02);
            nightstand.add(wallMount);
        }

        function buildTorre(w, d, h, mat, darkMat) {
            const body = new THREE.Mesh(new THREE.BoxGeometry(w * 0.8, h, d * 0.9), mat);
            body.position.y = h * 0.5;
            nightstand.add(body);

            for (let i = 0; i < 3; i++) {
                const drawerH = h / 3.5;
                const drawer = new THREE.Mesh(new THREE.BoxGeometry(w * 0.72, drawerH * 0.8, 0.008), darkMat);
                drawer.position.set(0, h * 0.15 + i * (h * 0.28), d * 0.45 + 0.005);
                nightstand.add(drawer);
            }
        }

        function buildHorizontal(w, d, h, mat, darkMat) {
            const bodyH = h * 0.6;
            const body = new THREE.Mesh(new THREE.BoxGeometry(w * 1.3, bodyH, d), mat);
            body.position.y = bodyH / 2 + h * 0.15;
            nightstand.add(body);

            // Two side-by-side drawers
            const drawerW = w * 0.55;
            [-1, 1].forEach(side => {
                const drawer = new THREE.Mesh(new THREE.BoxGeometry(drawerW, bodyH * 0.7, 0.008), darkMat);
                drawer.position.set(side * (w * 0.35), bodyH / 2 + h * 0.15, d / 2 + 0.005);
                nightstand.add(drawer);
            });

            const legH = h * 0.15;
            [[-1, -1], [1, -1], [-1, 1], [1, 1]].forEach(([sx, sz]) => {
                const leg = new THREE.Mesh(new THREE.BoxGeometry(0.025, legH, 0.025), mat);
                leg.position.set(sx * (w * 0.6), legH / 2, sz * (d / 2 - 0.02));
                nightstand.add(leg);
            });
        }

        function buildNicho(w, d, h, mat, darkMat) {
            // Open shelf top + drawer bottom
            const topShelf = new THREE.Mesh(new THREE.BoxGeometry(w, h * 0.45, d), mat);
            topShelf.position.y = h * 0.75;
            nightstand.add(topShelf);

            const bottomBox = new THREE.Mesh(new THREE.BoxGeometry(w, h * 0.35, d), mat);
            bottomBox.position.y = h * 0.25;
            nightstand.add(bottomBox);

            const drawer = new THREE.Mesh(new THREE.BoxGeometry(w * 0.9, h * 0.25, 0.008), darkMat);
            drawer.position.set(0, h * 0.25, d / 2 + 0.005);
            nightstand.add(drawer);
        }

        function buildMesa(w, d, h, mat, darkMat) {
            const top = new THREE.Mesh(new THREE.BoxGeometry(w, 0.02, d), mat);
            top.position.y = h * 0.9;
            nightstand.add(top);

            const shelf = new THREE.Mesh(new THREE.BoxGeometry(w * 0.9, 0.015, d * 0.9), mat);
            shelf.position.y = h * 0.35;
            nightstand.add(shelf);

            const legH = h * 0.88;
            [[-1, -1], [1, -1], [-1, 1], [1, 1]].forEach(([sx, sz]) => {
                const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, legH, 8), mat);
                leg.position.set(sx * (w / 2 - 0.03), legH / 2 + 0.01, sz * (d / 2 - 0.03));
                nightstand.add(leg);
            });
        }

        function buildEscalon(w, d, h, mat, darkMat) {
            const leftBox = new THREE.Mesh(new THREE.BoxGeometry(w * 0.55, h * 0.6, d), mat);
            leftBox.position.set(-w * 0.2, h * 0.3, 0);
            nightstand.add(leftBox);

            const rightBox = new THREE.Mesh(new THREE.BoxGeometry(w * 0.45, h * 0.85, d * 0.9), mat);
            rightBox.position.set(w * 0.25, h * 0.425, 0);
            nightstand.add(rightBox);

            const drawer = new THREE.Mesh(new THREE.BoxGeometry(w * 0.45, h * 0.4, 0.008), darkMat);
            drawer.position.set(-w * 0.2, h * 0.3, d / 2 + 0.005);
            nightstand.add(drawer);
        }

        function buildZocalo(w, d, h, mat, darkMat) {
            const body = new THREE.Mesh(new THREE.BoxGeometry(w, h * 0.8, d), mat);
            body.position.y = h * 0.5;
            nightstand.add(body);

            // Plinth base
            const plinth = new THREE.Mesh(new THREE.BoxGeometry(w + 0.01, h * 0.12, d + 0.01), mat);
            plinth.position.y = h * 0.06;
            nightstand.add(plinth);

            const drawerH = h * 0.35;
            for (let i = 0; i < 2; i++) {
                const drawer = new THREE.Mesh(new THREE.BoxGeometry(w * 0.9, drawerH * 0.85, 0.008), darkMat);
                drawer.position.set(0, h * 0.2 + i * drawerH, d / 2 + 0.005);
                nightstand.add(drawer);
            }
        }

        function buildCilindro(w, d, h, mat, darkMat) {
            const radius = Math.min(w, d) / 2;
            const body = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, h * 0.9, 24), mat);
            body.position.y = h * 0.45;
            nightstand.add(body);

            const drawerArc = new THREE.Mesh(new THREE.BoxGeometry(radius * 1.5, h * 0.3, 0.008), darkMat);
            drawerArc.position.set(0, h * 0.45, radius + 0.005);
            nightstand.add(drawerArc);
        }

        function buildHexagono(w, d, h, mat, darkMat) {
            const hexShape = new THREE.Shape();
            const size = Math.min(w, d) / 2;
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
                const x = Math.cos(angle) * size;
                const y = Math.sin(angle) * size;
                if (i === 0) hexShape.moveTo(x, y);
                else hexShape.lineTo(x, y);
            }
            hexShape.closePath();

            const extrudeSettings = { depth: h * 0.8, bevelEnabled: false };
            const hexGeo = new THREE.ExtrudeGeometry(hexShape, extrudeSettings);
            hexGeo.rotateX(-Math.PI / 2);
            const hex = new THREE.Mesh(hexGeo, mat);
            hex.position.y = h * 0.1;
            nightstand.add(hex);

            const drawer = new THREE.Mesh(new THREE.BoxGeometry(w * 0.6, h * 0.3, 0.008), darkMat);
            drawer.position.set(0, h * 0.5, size + 0.005);
            nightstand.add(drawer);
        }

        function buildAngular(w, d, h, mat, darkMat, metalMat) {
            // Trapezoid shape
            const shape = new THREE.Shape();
            const topW = w * 0.9;
            const botW = w;
            shape.moveTo(-botW / 2, 0);
            shape.lineTo(botW / 2, 0);
            shape.lineTo(topW / 2, h * 0.85);
            shape.lineTo(-topW / 2, h * 0.85);
            shape.closePath();

            const extrudeSettings = { depth: d, bevelEnabled: false };
            const geo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            geo.translate(0, 0, -d / 2);
            const body = new THREE.Mesh(geo, mat);
            nightstand.add(body);

            // Metal legs
            [[-1, -1], [1, -1]].forEach(([sx, sz]) => {
                const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, h * 0.12, 8), metalMat);
                leg.position.set(sx * (w / 2 - 0.04), -h * 0.02, sz * (d / 2 - 0.04));
                nightstand.add(leg);
            });

            for (let i = 0; i < 2; i++) {
                const drawer = new THREE.Mesh(new THREE.BoxGeometry(w * 0.75, h * 0.3, 0.008), darkMat);
                drawer.position.set(0, h * 0.25 + i * h * 0.35, d / 2 + 0.005);
                nightstand.add(drawer);
            }
        }

        function buildMarco(w, d, h, mat, darkMat, metalMat) {
            // Metal frame
            const frameT = 0.02;
            // Vertical posts
            [[-1, -1], [1, -1], [-1, 1], [1, 1]].forEach(([sx, sz]) => {
                const post = new THREE.Mesh(new THREE.BoxGeometry(frameT, h, frameT), metalMat);
                post.position.set(sx * (w / 2), h / 2, sz * (d / 2));
                nightstand.add(post);
            });
            // Horizontal rails
            [0, h].forEach(y => {
                const rail1 = new THREE.Mesh(new THREE.BoxGeometry(w, frameT, frameT), metalMat);
                rail1.position.set(0, y, d / 2);
                nightstand.add(rail1);
                const rail2 = new THREE.Mesh(new THREE.BoxGeometry(w, frameT, frameT), metalMat);
                rail2.position.set(0, y, -d / 2);
                nightstand.add(rail2);
            });

            // Inner box
            const innerBox = new THREE.Mesh(new THREE.BoxGeometry(w * 0.85, h * 0.6, d * 0.85), mat);
            innerBox.position.y = h * 0.45;
            nightstand.add(innerBox);
        }

        function buildCantilever(w, d, h, mat, darkMat, metalMat) {
            const body = new THREE.Mesh(new THREE.BoxGeometry(w, h * 0.35, d), mat);
            body.position.y = h * 0.6;
            nightstand.add(body);

            // C-shaped support
            const supportT = 0.025;
            const cSupport = new THREE.Group();
            const vert = new THREE.Mesh(new THREE.BoxGeometry(supportT, h * 0.7, supportT), metalMat);
            vert.position.set(-w / 2 - supportT, h * 0.35, 0);
            cSupport.add(vert);
            const horTop = new THREE.Mesh(new THREE.BoxGeometry(w * 0.2, supportT, supportT), metalMat);
            horTop.position.set(-w / 2 + w * 0.1 - supportT, h * 0.7, 0);
            cSupport.add(horTop);
            const horBot = new THREE.Mesh(new THREE.BoxGeometry(w * 0.3, supportT, d * 0.8), metalMat);
            horBot.position.set(-w / 2 + w * 0.15 - supportT, 0, 0);
            cSupport.add(horBot);
            nightstand.add(cSupport);

            const drawer = new THREE.Mesh(new THREE.BoxGeometry(w * 0.85, h * 0.2, 0.008), darkMat);
            drawer.position.set(0, h * 0.6, d / 2 + 0.005);
            nightstand.add(drawer);
        }

        function buildCristal(w, d, h, mat, darkMat, glassMat) {
            buildStandard(w, d, h, mat, darkMat, 2);

            // Glass top
            const glass = new THREE.Mesh(new THREE.BoxGeometry(w + 0.02, 0.01, d + 0.02), glassMat);
            glass.position.y = h * 0.95;
            nightstand.add(glass);
        }

        function buildOrganico(w, d, h, mat, darkMat) {
            // Rounded box using capsule-like shape
            const bodyGeo = new THREE.BoxGeometry(w, h * 0.75, d);
            bodyGeo.translate(0, h * 0.45, 0);

            // Add rounded corners simulation with spheres at corners
            const body = new THREE.Mesh(bodyGeo, mat);
            nightstand.add(body);

            // Rounded legs
            [[-1, -1], [1, -1], [-1, 1], [1, 1]].forEach(([sx, sz]) => {
                const leg = new THREE.Mesh(new THREE.SphereGeometry(0.04, 16, 16), mat);
                leg.scale.y = 2;
                leg.position.set(sx * (w / 2 - 0.04), 0.04, sz * (d / 2 - 0.04));
                nightstand.add(leg);
            });

            const drawer = new THREE.Mesh(new THREE.BoxGeometry(w * 0.85, h * 0.3, 0.008), darkMat);
            drawer.position.set(0, h * 0.45, d / 2 + 0.005);
            nightstand.add(drawer);
        }

        function buildColonial(w, d, h, mat, darkMat) {
            // Main body
            const body = new THREE.Mesh(new THREE.BoxGeometry(w, h * 0.7, d), mat);
            body.position.y = h * 0.5;
            nightstand.add(body);

            // Crown molding
            const crown = new THREE.Mesh(new THREE.BoxGeometry(w + 0.03, 0.03, d + 0.03), mat);
            crown.position.y = h * 0.86;
            nightstand.add(crown);

            // Cabriole-style legs (simplified)
            [[-1, -1], [1, -1], [-1, 1], [1, 1]].forEach(([sx, sz]) => {
                const legGroup = new THREE.Group();
                const upper = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.02, h * 0.12, 8), mat);
                upper.position.y = h * 0.08;
                legGroup.add(upper);
                const foot = new THREE.Mesh(new THREE.SphereGeometry(0.025, 8, 8), mat);
                foot.scale.y = 0.5;
                foot.position.y = 0.01;
                legGroup.add(foot);
                legGroup.position.set(sx * (w / 2 - 0.03), 0, sz * (d / 2 - 0.03));
                nightstand.add(legGroup);
            });

            for (let i = 0; i < 2; i++) {
                const drawer = new THREE.Mesh(new THREE.BoxGeometry(w * 0.85, h * 0.28, 0.008), darkMat);
                drawer.position.set(0, h * 0.3 + i * h * 0.32, d / 2 + 0.005);
                nightstand.add(drawer);
                // Round handles
                const handle = new THREE.Mesh(new THREE.TorusGeometry(0.015, 0.004, 8, 16), darkMat);
                handle.rotation.x = Math.PI / 2;
                handle.position.set(0, h * 0.3 + i * h * 0.32, d / 2 + 0.02);
                nightstand.add(handle);
            }
        }

        function buildRetro(w, d, h, mat, darkMat) {
            const body = new THREE.Mesh(new THREE.BoxGeometry(w, h * 0.7, d), mat);
            body.position.y = h * 0.55;
            nightstand.add(body);

            // Tapered legs (conical)
            [[-1, -1], [1, -1], [-1, 1], [1, 1]].forEach(([sx, sz]) => {
                const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.02, h * 0.25, 8), mat);
                leg.position.set(sx * (w / 2 - 0.04), h * 0.1, sz * (d / 2 - 0.04));
                leg.rotation.x = sx * sz * 0.1; // slight angle
                nightstand.add(leg);
            });

            for (let i = 0; i < 2; i++) {
                const drawer = new THREE.Mesh(new THREE.BoxGeometry(w * 0.88, h * 0.28, 0.008), darkMat);
                drawer.position.set(0, h * 0.4 + i * h * 0.3, d / 2 + 0.005);
                nightstand.add(drawer);
            }
        }

        function buildProvenzal(w, d, h, mat, darkMat) {
            const body = new THREE.Mesh(new THREE.BoxGeometry(w, h * 0.65, d), mat);
            body.position.y = h * 0.55;
            nightstand.add(body);

            // Turned legs
            [[-1, -1], [1, -1], [-1, 1], [1, 1]].forEach(([sx, sz]) => {
                const legGroup = new THREE.Group();
                // Multiple spheres stacked for turned look
                for (let j = 0; j < 3; j++) {
                    const ball = new THREE.Mesh(new THREE.SphereGeometry(0.018 - j * 0.003, 8, 8), mat);
                    ball.position.y = j * 0.06;
                    legGroup.add(ball);
                }
                const shaft = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.015, h * 0.15, 8), mat);
                shaft.position.y = h * 0.1;
                legGroup.add(shaft);
                legGroup.position.set(sx * (w / 2 - 0.03), 0.01, sz * (d / 2 - 0.03));
                nightstand.add(legGroup);
            });

            for (let i = 0; i < 2; i++) {
                const drawer = new THREE.Mesh(new THREE.BoxGeometry(w * 0.85, h * 0.25, 0.008), darkMat);
                drawer.position.set(0, h * 0.38 + i * h * 0.28, d / 2 + 0.005);
                nightstand.add(drawer);
            }
        }

        function buildChippendale(w, d, h, mat, darkMat) {
            const body = new THREE.Mesh(new THREE.BoxGeometry(w, h * 0.6, d), mat);
            body.position.y = h * 0.55;
            nightstand.add(body);

            // Cabriole legs (S-curve approximation)
            [[-1, -1], [1, -1], [-1, 1], [1, 1]].forEach(([sx, sz]) => {
                const curve = new THREE.CatmullRomCurve3([
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(sx * 0.02, h * 0.08, sz * 0.02),
                    new THREE.Vector3(sx * -0.01, h * 0.15, sz * -0.01),
                    new THREE.Vector3(0, h * 0.22, 0)
                ]);
                const tubeGeo = new THREE.TubeGeometry(curve, 12, 0.015, 8, false);
                const leg = new THREE.Mesh(tubeGeo, mat);
                leg.position.set(sx * (w / 2 - 0.03), 0, sz * (d / 2 - 0.03));
                nightstand.add(leg);

                // Ball foot
                const foot = new THREE.Mesh(new THREE.SphereGeometry(0.02, 8, 8), mat);
                foot.position.set(sx * (w / 2 - 0.03), 0.015, sz * (d / 2 - 0.03));
                nightstand.add(foot);
            });

            for (let i = 0; i < 2; i++) {
                const drawer = new THREE.Mesh(new THREE.BoxGeometry(w * 0.85, h * 0.22, 0.008), darkMat);
                drawer.position.set(0, h * 0.38 + i * h * 0.24, d / 2 + 0.005);
                nightstand.add(drawer);
            }
        }

        function buildArtDeco(w, d, h, mat, darkMat, metalMat) {
            const body = new THREE.Mesh(new THREE.BoxGeometry(w, h * 0.8, d), mat);
            body.position.y = h * 0.5;
            nightstand.add(body);

            // Stepped top
            const step1 = new THREE.Mesh(new THREE.BoxGeometry(w * 0.95, 0.02, d * 0.95), mat);
            step1.position.y = h * 0.91;
            nightstand.add(step1);
            const step2 = new THREE.Mesh(new THREE.BoxGeometry(w * 0.88, 0.02, d * 0.88), mat);
            step2.position.y = h * 0.95;
            nightstand.add(step2);

            // Gold accents
            const accent1 = new THREE.Mesh(new THREE.BoxGeometry(0.008, h * 0.6, 0.008), metalMat);
            accent1.position.set(-w / 2 + 0.03, h * 0.5, d / 2 + 0.005);
            nightstand.add(accent1);
            const accent2 = new THREE.Mesh(new THREE.BoxGeometry(0.008, h * 0.6, 0.008), metalMat);
            accent2.position.set(w / 2 - 0.03, h * 0.5, d / 2 + 0.005);
            nightstand.add(accent2);

            for (let i = 0; i < 2; i++) {
                const drawer = new THREE.Mesh(new THREE.BoxGeometry(w * 0.8, h * 0.3, 0.008), darkMat);
                drawer.position.set(0, h * 0.25 + i * h * 0.35, d / 2 + 0.005);
                nightstand.add(drawer);
            }
        }

        function buildIngles(w, d, h, mat, darkMat) {
            // Taller with gallery
            const body = new THREE.Mesh(new THREE.BoxGeometry(w, h * 0.75, d), mat);
            body.position.y = h * 0.45;
            nightstand.add(body);

            // Gallery rail
            const railH = h * 0.08;
            [[-1, 0], [1, 0], [0, -1]].forEach(([sx, sz]) => {
                const rail = new THREE.Mesh(new THREE.BoxGeometry(
                    sz === 0 ? 0.008 : w * 0.9,
                    railH,
                    sx === 0 ? 0.008 : d * 0.9
                ), mat);
                rail.position.set(sx * (w / 2 - 0.02), h * 0.87, sz * (d / 2 - 0.02));
                nightstand.add(rail);
            });

            // Open shelf + drawer
            const shelf = new THREE.Mesh(new THREE.BoxGeometry(w * 0.9, 0.01, d * 0.9), mat);
            shelf.position.y = h * 0.55;
            nightstand.add(shelf);

            const drawer = new THREE.Mesh(new THREE.BoxGeometry(w * 0.85, h * 0.3, 0.008), darkMat);
            drawer.position.set(0, h * 0.3, d / 2 + 0.005);
            nightstand.add(drawer);
        }

        function buildPuerta(w, d, h, mat, darkMat) {
            const body = new THREE.Mesh(new THREE.BoxGeometry(w, h * 0.85, d), mat);
            body.position.y = h * 0.5;
            nightstand.add(body);

            // Door instead of drawer
            const door = new THREE.Mesh(new THREE.BoxGeometry(w * 0.9, h * 0.65, 0.015), darkMat);
            door.position.set(0, h * 0.45, d / 2 + 0.008);
            nightstand.add(door);

            // Door handle
            const handle = new THREE.Mesh(new THREE.SphereGeometry(0.015, 8, 8), darkMat);
            handle.position.set(w * 0.35, h * 0.45, d / 2 + 0.025);
            nightstand.add(handle);

            const legH = h * 0.1;
            [[-1, -1], [1, -1], [-1, 1], [1, 1]].forEach(([sx, sz]) => {
                const leg = new THREE.Mesh(new THREE.BoxGeometry(0.025, legH, 0.025), mat);
                leg.position.set(sx * (w / 2 - 0.02), legH / 2, sz * (d / 2 - 0.02));
                nightstand.add(leg);
            });
        }

        function buildCubo(w, d, h, mat, darkMat) {
            // Simple cube with one drawer
            const size = Math.min(w, d, h * 0.8);
            const body = new THREE.Mesh(new THREE.BoxGeometry(size, size, size), mat);
            body.position.y = size / 2 + h * 0.1;
            nightstand.add(body);

            const drawer = new THREE.Mesh(new THREE.BoxGeometry(size * 0.85, size * 0.75, 0.008), darkMat);
            drawer.position.set(0, size / 2 + h * 0.1, size / 2 + 0.005);
            nightstand.add(drawer);

            const legH = h * 0.1;
            [[-1, -1], [1, -1], [-1, 1], [1, 1]].forEach(([sx, sz]) => {
                const leg = new THREE.Mesh(new THREE.BoxGeometry(0.03, legH, 0.03), mat);
                leg.position.set(sx * (size / 2 - 0.02), legH / 2, sz * (size / 2 - 0.02));
                nightstand.add(leg);
            });
        }

        function addTechIndicators(w, d, h, mat) {
            // Wireless charger indicator
            if (config.gadgets.includes('wireless')) {
                const charger = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.035, 0.035, 0.004, 16),
                    new THREE.MeshStandardMaterial({ color: 0x222222 })
                );
                charger.position.set(0, h * 0.96, 0);
                nightstand.add(charger);
            }

            // LED indicator
            if (config.gadgets.includes('led')) {
                const led = new THREE.Mesh(
                    new THREE.BoxGeometry(w * 0.8, 0.005, 0.005),
                    new THREE.MeshBasicMaterial({ color: 0xF5A623 })
                );
                led.position.set(0, h * 0.08, d / 2 + 0.003);
                nightstand.add(led);
            }

            // USB indicator
            if (config.gadgets.includes('usb')) {
                const usb = new THREE.Mesh(
                    new THREE.BoxGeometry(0.025, 0.01, 0.01),
                    new THREE.MeshStandardMaterial({ color: 0x222222 })
                );
                usb.position.set(w * 0.35, h * 0.15, d / 2 + 0.006);
                nightstand.add(usb);
            }
        }

        buildModel();

        // Mouse drag
        let dragging = false;
        canvas.onmousedown = () => dragging = true;
        canvas.onmouseup = () => dragging = false;
        canvas.onmouseleave = () => dragging = false;
        canvas.onmousemove = e => {
            if (dragging) nightstand.rotation.y += e.movementX * 0.01;
        };

        // Touch support
        let lastTouchX = 0;
        canvas.ontouchstart = e => {
            lastTouchX = e.touches[0].clientX;
            dragging = true;
        };
        canvas.ontouchend = () => dragging = false;
        canvas.ontouchmove = e => {
            if (dragging && e.touches.length === 1) {
                const deltaX = e.touches[0].clientX - lastTouchX;
                nightstand.rotation.y += deltaX * 0.01;
                lastTouchX = e.touches[0].clientX;
            }
        };

        // Animation
        (function animate() {
            requestAnimationFrame(animate);
            if (!dragging) nightstand.rotation.y += 0.003;
            renderer.render(scene, camera);
        })();

        // Resize
        window.onresize = () => {
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        };

        // Sliders
        ['ancho', 'prof', 'alto'].forEach(dim => {
            const slider = document.getElementById('s-' + dim);
            const value = document.getElementById('v-' + dim);
            slider.oninput = () => {
                config[dim] = parseInt(slider.value);
                value.textContent = slider.value + ' cm';
                buildModel();
            };
        });

        // Colors
        document.querySelectorAll('.color-opt').forEach(opt => {
            opt.onclick = () => {
                document.querySelectorAll('.color-opt').forEach(o => o.classList.remove('active'));
                opt.classList.add('active');
                config.color = parseInt(opt.dataset.color);
                config.colorName = opt.dataset.name;
                config.materialMod = parseInt(opt.dataset.mod);
                buildModel();
                updateSummary();
            };
        });

        // Gadgets
        document.querySelectorAll('.gadget').forEach(g => {
            g.onclick = () => {
                g.classList.toggle('active');
                const gadget = g.dataset.gadget;
                if (g.classList.contains('active')) {
                    config.gadgets.push(gadget);
                } else {
                    config.gadgets = config.gadgets.filter(x => x !== gadget);
                }
                buildModel();
                updateSummary();
            };
        });

        // Summary
        function updateSummary() {
            const extrasTotal = config.gadgets.reduce((sum, g) => {
                const el = document.querySelector(`[data-gadget="${g}"]`);
                return sum + parseInt(el?.dataset.precio || 0);
            }, 0);

            const total = config.precioBase + config.materialMod + extrasTotal;

            document.getElementById('sum-base').textContent = '$' + config.precioBase.toLocaleString('es-CL');
            document.getElementById('sum-mat').textContent = (config.materialMod >= 0 ? '+' : '') + '$' + config.materialMod.toLocaleString('es-CL');
            document.getElementById('sum-extras').textContent = '+$' + extrasTotal.toLocaleString('es-CL');
            document.getElementById('sum-total').textContent = '$' + total.toLocaleString('es-CL');
        }

        updateSummary();

        // WhatsApp
        const WHATSAPP_NUMBER = '56966172583';

        function cotizar() {
            const total = config.precioBase + config.materialMod + config.gadgets.reduce((sum, g) => {
                const el = document.querySelector(`[data-gadget="${g}"]`);
                return sum + parseInt(el?.dataset.precio || 0);
            }, 0);

            // Track analytics event
            if (typeof trackWhatsAppClick === 'function') {
                trackWhatsAppClick(config.modelo, config.nombre, total);
            }
            if (typeof trackInitiateCheckout === 'function') {
                trackInitiateCheckout(config.modelo, config.nombre, total, config);
            }

            const extras = config.gadgets.length ? config.gadgets.join(', ') : 'ninguno';
            const msg = `Hola! Me interesa el velador *${config.nombre}*:\n` +
                `- Medidas: ${config.ancho}x${config.prof}x${config.alto} cm\n` +
                `- Color: ${config.colorName}\n` +
                `- Extras: ${extras}\n` +
                `- Total: $${total.toLocaleString('es-CL')}\n\n` +
                `¿Está disponible?`;

            window.open('https://wa.me/' + WHATSAPP_NUMBER + '?text=' + encodeURIComponent(msg), '_blank');
        }
    </script>

</body>

</html>